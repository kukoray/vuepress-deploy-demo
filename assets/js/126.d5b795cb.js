(window.webpackJsonp=window.webpackJsonp||[]).push([[126],{543:function(t,n,e){"use strict";e.r(n);var r=e(65),a=Object(r.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"mysql"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mysql"}},[t._v("#")]),t._v(" mysql")]),t._v(" "),e("h2",{attrs:{id:"mysql主从复制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mysql主从复制"}},[t._v("#")]),t._v(" mysql主从复制")]),t._v(" "),e("p",[t._v("MySQL主从复制是一个异步的复制过程，底层是基于Mysql数据库自带的二进制日志功能。就是一台或多台MySQL数据库(slave，即从库)从另一台MySQL数据库(master，即主库）"),e("strong",[t._v("进行日志的复制然后再解析日志并应用到自身，最终实现从库的数据和主库的数据保持一致")]),t._v("。MySQL主从复制是MySQL数据库自带功能，无需借助第三方工具。")]),t._v(" "),e("p",[t._v("我们可以通过mysql的主从复制，来实现"),e("strong",[t._v("读写分离")])]),t._v(" "),e("p",[t._v("我的服务器mysql配置文件在/etc/mysql/mysql.conf.d/mysqld.cnf")]),t._v(" "),e("p",[t._v("mysql的数据是保存在，/var/lib/mysql/ 这个 目录下，每新建一个数据库就是在这个目录下新增一个文件夹")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://s2.loli.net/2022/10/29/RGrTkIZhnwHNldt.png",alt:"image-20221029094343597"}})]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[t._v("第一步:修改Mysql数据库的配置文件/etc/my "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v(".")]),t._v(" cnf\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("mysqld"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\nlog-bin"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("mysql-bin\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#[必须]启用二进制日志")]),t._v("\nserver-id"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#[必须]服务器唯一ID")]),t._v("\n")])])]),e("div",{staticClass:"language-mysql extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("第二步:重启mysql服务\nsystemctl restart mysqld\n\n第三步:登录Mysql数据库,执行下面SQL\nGRANT REPLICATION SLAVE ON *.* to 'xiaoming'@'%' identified by 'Root@123456';\n注:上面SQL的作用是创建一个用户xiaoming,密码为Root@123456,并且给xiaoming用户授予REPLICATION SLAVE\n权限。常用于建立复制时所需要用到的用户权限，也就是slave必须被master授权具有该权限的用户，才能通过该用户复制。\n\n\n")])])]),e("h2",{attrs:{id:"mysql-基础架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mysql-基础架构"}},[t._v("#")]),t._v(" MySQL 基础架构")]),t._v(" "),e("p",[t._v("连接器->分析器->优化器->执行器")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://s2.loli.net/2022/12/07/8qxz1tJLv2eiyPR.png",alt:"img"}})]),t._v(" "),e("p",[t._v("存储引擎是基于表的，而不是数据库")]),t._v(" "),e("h2",{attrs:{id:"索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#索引"}},[t._v("#")]),t._v(" 索引")]),t._v(" "),e("p",[t._v("B树，m叉数")]),t._v(" "),e("p",[t._v("B+树，多叉树")]),t._v(" "),e("p",[e("strong",[t._v("B 树& B+树两者有何异同呢？")])]),t._v(" "),e("ul",[e("li",[t._v("B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。")]),t._v(" "),e("li",[t._v("B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。")]),t._v(" "),e("li",[t._v("B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。")])]),t._v(" "),e("h2",{attrs:{id:"模拟数据脚本"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模拟数据脚本"}},[t._v("#")]),t._v(" 模拟数据脚本")]),t._v(" "),e("h2",{attrs:{id:"checkpoint"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#checkpoint"}},[t._v("#")]),t._v(" checkpoint")]),t._v(" "),e("p",[t._v("在"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink",target:"_blank",rel:"noopener noreferrer"}},[t._v("数据库系统"),e("OutboundLink")],1),t._v("中，写日志和写数据文件是数据库中IO消耗最大的两种操作，在这两种操作中写数据文件属于分散写，写日志文件是顺序写，因此为了保证数据库的性能，通常数据库都是保证在提交("),e("a",{attrs:{href:"https://baike.baidu.com/item/commit/9214278?fromModule=lemma_inlink",target:"_blank",rel:"noopener noreferrer"}},[t._v("commit"),e("OutboundLink")],1),t._v(")完成之前要先保证日志都被写入到日志文件中，而脏数据块则保存在数据缓存(buffer cache)中再不定期的分批写入到数据文件中。也就是说日志写入和提交操作是同步的，而数据写入和提交操作是不同步的。这样就存在一个问题，当一个数据库崩溃的时候并不能保证缓存里面的"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E8%84%8F%E6%95%B0%E6%8D%AE/631511?fromModule=lemma_inlink",target:"_blank",rel:"noopener noreferrer"}},[t._v("脏数据"),e("OutboundLink")],1),t._v("全部写入到数据文件中，这样在实例启动的时候就要使用日志文件进行恢复操作，将"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D/3949044?fromModule=lemma_inlink",target:"_blank",rel:"noopener noreferrer"}},[t._v("数据库恢复"),e("OutboundLink")],1),t._v("到崩溃之前的状态，保证数据的一致性。检查点是这个过程中的重要机制，通过它来确定，恢复时哪些重做日志应该被扫描并应用于恢复。")]),t._v(" "),e("p",[t._v("一般所说的checkpoint是一个数据库事件(event)，checkpoint事件由checkpoint进程("),e("a",{attrs:{href:"https://baike.baidu.com/item/LGWR/1281226?fromModule=lemma_inlink",target:"_blank",rel:"noopener noreferrer"}},[t._v("LGWR"),e("OutboundLink")],1),t._v("/"),e("a",{attrs:{href:"https://baike.baidu.com/item/CKPT/1274375?fromModule=lemma_inlink",target:"_blank",rel:"noopener noreferrer"}},[t._v("CKPT"),e("OutboundLink")],1),t._v("进程)发出，当checkpoint事件发生时"),e("a",{attrs:{href:"https://baike.baidu.com/item/DBWR/1274116?fromModule=lemma_inlink",target:"_blank",rel:"noopener noreferrer"}},[t._v("DBWR"),e("OutboundLink")],1),t._v("会将脏块写入到磁盘中，同时数据文件和控制文件的"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E5%A4%B4/2695144?fromModule=lemma_inlink",target:"_blank",rel:"noopener noreferrer"}},[t._v("文件头"),e("OutboundLink")],1),t._v("也会被更新以记录checkpoint信息。")]),t._v(" "),e("p",[t._v("作用：")]),t._v(" "),e("ul",[e("li",[t._v("保证数据库的一致性，这是指"),e("strong",[t._v("将脏数据写入到硬盘，保证内存和硬盘上的数据是一样的")]),t._v(";")]),t._v(" "),e("li",[t._v("缩短实例恢复的时间，实例恢复要把实例异常关闭前没有写出到硬盘的"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E8%84%8F%E6%95%B0%E6%8D%AE/631511?fromModule=lemma_inlink",target:"_blank",rel:"noopener noreferrer"}},[t._v("脏数据"),e("OutboundLink")],1),t._v("通过日志进行恢复。如果脏块过多，实例恢复的时间也会很长，检查点的发生可以"),e("strong",[t._v("减少脏块的数量，从而提高实例恢复的时间")]),t._v("。")])]),t._v(" "),e("h2",{attrs:{id:"备份与恢复"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#备份与恢复"}},[t._v("#")]),t._v(" 备份与恢复")]),t._v(" "),e("p",[t._v("mysqldump")]),t._v(" "),e("h2",{attrs:{id:"mysql脚本"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mysql脚本"}},[t._v("#")]),t._v(" mysql脚本")]),t._v(" "),e("div",{staticClass:"language-mysql extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('SELECT * FROM `test`\n\nDELIMITER $$\nCREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)\nBEGIN\n\tDECLARE chars_str VARCHAR(100) DEFAULT \'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\';\n\tDECLARE return_str VARCHAR(255) DEFAULT \'\';\n\tDECLARE i INT DEFAULT 0;\n\t\n\tWHILE i < n DO\n\t\tSET return_str=CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));\n\t\tSET i = i+1;\n\tEND WHILE;\n\tRETURN return_str;\nEND $$\n\n\nDELIMITER $$\nCREATE FUNCTION rand_num() RETURNS INT(5)\nBEGIN\n\tDECLARE i INT DEFAULT 0;\n\tSET i = FLOOR(10 + RAND()*10000);\n\tRETURN i;\nEND $$\n\n\nDELIMITER $$\nCREATE FUNCTION rand_datetime(sd DATETIME,ed DATETIME) RETURNS DATETIME\nBEGIN\n\tRETURN DATE_ADD(sd,INTERVAL FLOOR(1+RAND()*((ABS(UNIX_TIMESTAMP(ed)-UNIX_TIMESTAMP(sd)))-1)) SECOND);\nEND$$\n\n\nDELIMITER $$\nCREATE FUNCTION rand_factor() RETURNS VARCHAR(255)\nBEGIN\n\tDECLARE i INT DEFAULT 0;\n\tDECLARE return_str VARCHAR(255) DEFAULT \'\';\n\tSET i = RAND()*2;\n\tIF i%2 =1 THEN\n\t\tSET return_str="new_buy_order_value";\n\tELSE\n\t\tSET return_str="new_sell_order_value";\n\tEND IF;\n\t\t\n\tRETURN return_str;\nEND $$\n\n\n\n\nDELIMITER $$\nCREATE PROCEDURE insert_flink(IN max_num INT(10))\nBEGIN\n\tDECLARE i INT DEFAULT 0;\n\tSET autocommit = 0;\n\tREPEAT\n\t\tSET i = i + 1;\n\t\tINSERT INTO test(SecurityID,FactorName,TradeDate,`Value`) VALUES(rand_string(7),rand_factor(),rand_datetime("2023-01-01 00:00:00","2023-12-31 23:59:59"),rand_num());\n\tUNTIL i = max_num\n\tEND REPEAT;\n\tCOMMIT;\nEND $$\n\n\nDELIMITER ;\nCALL insert_flink(10);\n')])])])])}),[],!1,null,null,null);n.default=a.exports}}]);