(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{436:function(t,v,_){"use strict";_.r(v);var e=_(65),a=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"数据库系统"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库系统"}},[t._v("#")]),t._v(" 数据库系统")]),t._v(" "),_("h2",{attrs:{id:"什么是数据独立性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是数据独立性"}},[t._v("#")]),t._v(" 什么是数据独立性")]),t._v(" "),_("p",[t._v("数据独立性：分为 逻辑独立性和物理独立性")]),t._v(" "),_("p",[t._v("逻辑独立性：当模式改变时，通过对各个外模式/模式映像的调整，使外模式保持不变，使得应用程序不需要做任何修改。")]),t._v(" "),_("p",[t._v("物理独立性：当内模式改变时，通过对模式/内模式映像的调整，使模式保持不变，使得应用程序不需要做任何修改。")]),t._v(" "),_("p",[t._v("ps：内模式、模式只有一个，外模式有多个。")]),t._v(" "),_("h2",{attrs:{id:"数据库三大范式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库三大范式"}},[t._v("#")]),t._v(" 数据库三大范式")]),t._v(" "),_("blockquote",[_("p",[t._v("第一范式(1NF)："),_("strong",[t._v("属性不可分割")]),t._v("，即每个属性都是不可分割的原子项。(实体的属性即表中的列)")]),t._v(" "),_("p",[t._v("第二范式(2NF)：满足第一范式；且不存在"),_("strong",[t._v("部分依赖")]),t._v("，即非主属性必须完全依赖于主属性。(主属性即主键；完全依赖是针对于联合主键的情况，非主键列不能只依赖于主键的一部分)")]),t._v(" "),_("p",[t._v("第三范式(3NF)：满足第二范式；且不存在"),_("strong",[t._v("传递依赖")]),t._v("，即非主属性不能与非主属性之间有依赖关系，非主属性必须直接依赖于主属性，不能间接依赖主属性。（A -> B, B ->C, A -> C）")])]),t._v(" "),_("h2",{attrs:{id:"数据库的完整性约束"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库的完整性约束"}},[t._v("#")]),t._v(" 数据库的完整性约束")]),t._v(" "),_("p",[t._v("实体完整性：主属性非空")]),t._v(" "),_("p",[t._v("参照完整性：外码取空值或关系中的主码值")]),t._v(" "),_("p",[t._v("用户定义的完整性：unique，check，not null")]),t._v(" "),_("h2",{attrs:{id:"并发带来的数据不一致"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并发带来的数据不一致"}},[t._v("#")]),t._v(" 并发带来的数据不一致")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("丢失修改")]),t._v(" "),_("p",[t._v("T2提交的结果破坏了T1提交的结果")])]),t._v(" "),_("li",[_("p",[t._v("不可重复读")]),t._v(" "),_("p",[t._v("T1读该值，T2给她修改了，导致T1无法再现前一次读的结果")])]),t._v(" "),_("li",[_("p",[t._v("读脏数据")]),t._v(" "),_("p",[t._v("T1修改其值并写回，T2去读该值，然后T1回滚了。")])])]),t._v(" "),_("p",[t._v("两种锁：X锁和S锁（也叫写锁和读锁）")]),t._v(" "),_("ul",[_("li",[t._v("X锁：只允许T读A和修改A，任和锁其他食物都不能加")]),t._v(" "),_("li",[t._v("S锁：允许T读A但不能修改A，其他事务只能对A加S锁。")])]),t._v(" "),_("p",[t._v("封锁协议：")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("一级封锁：解决的是“丢失修改的问题”")]),t._v(" "),_("p",[t._v("​\t\t\t\t事务T在修改数据R之前必须加上X锁")])]),t._v(" "),_("li",[_("p",[t._v("二级封锁：解决的是“丢失修改”+“读脏数据”的问题")]),t._v(" "),_("p",[t._v("​\t\t\t\t在一级封锁的基础上，增加T在读取R之前加S锁，读完释放")])]),t._v(" "),_("li",[_("p",[t._v("三级封锁：解决的是“丢失修改”+“读脏数据”+“不可重复读“")]),t._v(" "),_("p",[t._v("​\t\t\t\t在一级封锁的基础上，增加T在读取R之前加S锁，事务结束后才释放")])])]),t._v(" "),_("h2",{attrs:{id:"恢复策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#恢复策略"}},[t._v("#")]),t._v(" 恢复策略")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("事务故障")]),t._v(" "),_("p",[t._v("采用UNDO，反向扫描日志文件，进行逆操作，直至事务的开始标记。")])]),t._v(" "),_("li",[_("p",[t._v("系统故障")]),t._v(" "),_("p",[t._v("REDO+UNDO")]),t._v(" "),_("p",[t._v("正向扫描，对故障发生之前已经提交的事务加入REDO-list；对于未完成的事务加入UNDO-list；")])])]),t._v(" "),_("h2",{attrs:{id:"acid"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#acid"}},[t._v("#")]),t._v(" ACID")]),t._v(" "),_("p",[t._v("原子性：每个操作原子不可再分")]),t._v(" "),_("p",[t._v("一致性：数据库操作前后数据库的正确性保持一致")]),t._v(" "),_("p",[t._v("隔离性：多个并发"),_("strong",[t._v("事务")]),t._v("之间要相互"),_("strong",[t._v("隔离")])]),t._v(" "),_("p",[t._v("持久性：入库后，就永久更新")]),t._v(" "),_("h2",{attrs:{id:"dql"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dql"}},[t._v("#")]),t._v(" DQL")]),t._v(" "),_("p",[t._v("join默认是内连接，也被称为自然连接")]),t._v(" "),_("p",[t._v("inner join：两个表值都存在")]),t._v(" "),_("p",[t._v("outer join：附表中值可能存在null的情况。")]),t._v(" "),_("div",{staticClass:"language-mysql extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("select FirstName,LastName,City,State \nfrom Person left join Address\non Person.PersonId = Address.PersonId\n")])])]),_("p",[t._v("limit不支持运算，所以不能直接N-1，需要先声明一个int型变量m，并且set他的值为N-1。\n另外，这题不需要再为列起别名，因为在一个函数里，这个函数返回的是一个int值，那么后台在调用这个函数时，返回的列名就是——函数名(N)")]),t._v(" "),_("div",{staticClass:"language-mysql extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT\nBEGIN\nset N = N-1;\n  RETURN (\n      # Write your MySQL query statement below.\n        select(\n          select distinct salary\n          from Employee\n          order by salary desc\n          limit N, 1\n      ) as getNthHighestSalary\n  );\nEND\n")])])]),_("p",[t._v("limit\n"),_("code",[t._v("select * from product limit 3;")])]),t._v(" "),_("p",[t._v("limit只有一个参数值，将表中的前三条数据查询出来")]),t._v(" "),_("p",[_("code",[t._v("select * from product limit 3,2;")])]),t._v(" "),_("p",[t._v("limit有两个参数，第一个参数表示从第（几+1）行数据开始查，第二个参数表示查几条数据，“limit 3,2”表示从第四行数据开始，取两条数据。")]),t._v(" "),_("blockquote",[_("p",[t._v("1、select* from user limit 3")]),t._v(" "),_("p",[t._v("表示直接取前三条数据")]),t._v(" "),_("p",[t._v("2、select * from user limit 1,3;")]),t._v(" "),_("p",[t._v("表示取1后面的第2,3,4三条条数据")]),t._v(" "),_("p",[t._v("3、select * from user limit 3 offset 1;")]),t._v(" "),_("p",[t._v("表示取1后面第2,3,4三条条数据")])]),t._v(" "),_("p",[t._v("使用变量前，需要先declare")]),t._v(" "),_("p",[_("code",[t._v("declare m INT")])]),t._v(" "),_("p",[_("code",[t._v("dateDiff(b.recordDate,a.recordDate)=1")])]),t._v(" "),_("ol",[_("li",[_("p",[t._v("rank() over\n作用：查出指定条件后的进行排名，条件相同排名相同，排名间断不连续。\n说明：例如学生排名，使用这个函数，成绩相同的两名是并列，下一位同学空出所占的名次。即：1 1 3 4 5 5 7")])]),t._v(" "),_("li",[_("p",[t._v("dense_rank() over\n作用：查出指定条件后的进行排名，条件相同排名相同，排名间断不连续。\n说明：和rank() over 的作用相同，区别在于dense_rank() over 排名是密集连续的。例如学生排名，使用这个函数，成绩相同的两名是并列，下一位同学接着下一个名次。即：1 1 2 3 4 5 5 6")])]),t._v(" "),_("li",[_("p",[t._v("row_number() over\n作用：查出指定条件后的进行排名，条件相同排名也不相同，排名间断不连续。\n说明：这个函数不需要考虑是否并列，即使根据条件查询出来的数值相同也会进行连续排序。即：1 2 3 4 5 6")])])]),t._v(" "),_("div",{staticClass:"language-mysql extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("# Write your MySQL query statement below\nselect score, dense_rank() over (order by score desc) as 'rank'  \nfrom scores;\n#这个rank之所以要加引号，因为rank本身是个函数，直接写rank会报错\n")])])]),_("p",[t._v("where>group by>having>order by")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[t._v("\t1、from\n\t2、on\n\t3、join\n---------------------确定表\n\t4、where\n\t5、group by\n\t6、having\n---------------------确定筛选条件\n\t7、select\n\t8、distinct\n---------------------确定显示字段\n\t9、order by\n\t10、limit\n---------------------确定显示效果\n")])])]),_("p",[_("img",{attrs:{src:"https://s2.loli.net/2022/12/08/viQtXSw9qsuFx7o.png",alt:"img"}})]),t._v(" "),_("h2",{attrs:{id:"myisam-和-innodb"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#myisam-和-innodb"}},[t._v("#")]),t._v(" MyISAM 和 InnoDB")]),t._v(" "),_("p",[t._v("行级锁与表级锁")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。"),_("strong",[t._v("不支持事务")])])]),t._v(" "),_("li",[_("p",[t._v("InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("表级锁：")]),t._v(" MySQL 中锁定粒度最大的一种锁，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("行级锁：")]),t._v(" MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。")])])]),t._v(" "),_("h2",{attrs:{id:"锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[t._v("#")]),t._v(" 锁")]),t._v(" "),_("p",[t._v("不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("共享锁（S 锁）")]),t._v(" ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。")]),t._v(" "),_("li",[_("strong",[t._v("排他锁（X 锁）")]),t._v(" ：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。")])]),t._v(" "),_("p",[t._v("排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"left"}}),t._v(" "),_("th",{staticStyle:{"text-align":"left"}},[t._v("S 锁")]),t._v(" "),_("th",{staticStyle:{"text-align":"left"}},[t._v("X 锁")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("S 锁")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("不冲突")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("冲突")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("X 锁")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("冲突")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("冲突")])])])]),t._v(" "),_("h3",{attrs:{id:"意向锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#意向锁"}},[t._v("#")]),t._v(" 意向锁")]),t._v(" "),_("p",[t._v("意向锁可以帮助快速判断是否可以对一个表使用表锁（因为如果要加表锁的话，要求表内没有行锁，并且表没有表锁）")]),t._v(" "),_("p",[t._v("意向锁是表级锁，共有两种：")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("意向共享锁（IS 锁）")]),t._v("：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。")]),t._v(" "),_("li",[_("strong",[t._v("意向排他锁（IX 锁）")]),t._v("：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。")])]),t._v(" "),_("p",[t._v("在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。")]),t._v(" "),_("h2",{attrs:{id:"备份"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#备份"}},[t._v("#")]),t._v(" 备份")]),t._v(" "),_("p",[_("code",[t._v("mysqldump -h主机名 -P端口 -u用户名 -p密码 –database 数据库名 > 文件名.sql")])]),t._v(" "),_("h2",{attrs:{id:"执行流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#执行流程"}},[t._v("#")]),t._v(" 执行流程")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s2.loli.net/2022/12/09/FkrGZxH164p8KwJ.png",alt:"img"}})]),t._v(" "),_("h3",{attrs:{id:"第一步-连接器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第一步-连接器"}},[t._v("#")]),t._v(" 第一步：连接器")]),t._v(" "),_("p",[t._v("mysql是基于tcp协议进行传输的")]),t._v(" "),_("p",[t._v("mysql是默认长连接，8h 空闲连接")]),t._v(" "),_("p",[t._v("最多连接数，151个")]),t._v(" "),_("h3",{attrs:{id:"第二步-查询缓存-select"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第二步-查询缓存-select"}},[t._v("#")]),t._v(" 第二步：查询缓存（select）")]),t._v(" "),_("p",[t._v("MySQL 服务收到 SQL 语句后，"),_("strong",[t._v("就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。")])]),t._v(" "),_("p",[t._v("如果 SQL 是查询语句（select 语句），"),_("strong",[t._v("MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据")]),t._v("，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。")]),t._v(" "),_("h3",{attrs:{id:"第三步-解析sql"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第三步-解析sql"}},[t._v("#")]),t._v(" 第三步：解析SQL")]),t._v(" "),_("p",[t._v("词法分析")]),t._v(" "),_("p",[t._v("语法分析")]),t._v(" "),_("h3",{attrs:{id:"第四步-执行sql"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第四步-执行sql"}},[t._v("#")]),t._v(" 第四步：执行SQL")]),t._v(" "),_("p",[_("strong",[t._v("预处理")])]),t._v(" "),_("p",[_("strong",[t._v("优化器")])]),t._v(" "),_("p",[t._v("要想知道优化器选择了哪个索引，我们可以在查询语句最前面加个 "),_("code",[t._v("explain")]),t._v(" 命令（常用于排查慢sql的原因），这样就会输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引，比如下图的 key 为 "),_("code",[t._v("PRIMARY")]),t._v(" 就是使用了主键索引。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s2.loli.net/2022/12/09/otqEX19NC5ypciG.png",alt:"img"}})]),t._v(" "),_("p",[t._v("key如果是null，那就执行全表扫描")]),t._v(" "),_("p",[_("strong",[t._v("执行")])]),t._v(" "),_("h2",{attrs:{id:"数据存储"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据存储"}},[t._v("#")]),t._v(" 数据存储")]),t._v(" "),_("p",[t._v("我们每创建一个 database（数据库） 都会在 /var/lib/mysql/ 目录里面创建一个以 database 为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里。")]),t._v(" "),_("p",[t._v("比如，我这里有一个名为 my_test 的 database，该 database 里有一张名为 t_order 数据库表。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s2.loli.net/2022/12/09/jN6vIxpE2mGuM4Z.png",alt:"img"}})]),t._v(" "),_("p",[t._v("然后，我们进入 /var/lib/mysql/my_test 目录，看看里面有什么文件？")]),t._v(" "),_("div",{staticClass:"language-shell extra-class"},[_("pre",{pre:!0,attrs:{class:"language-shell"}},[_("code",[_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("root@xiaolin ~"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#ls /var/lib/mysql/my_test")]),t._v("\ndb.opt  \nt_order.frm  \nt_order.ibd\n")])])]),_("p",[t._v("可以看到，共有三个文件，这三个文件分别代表着：")]),t._v(" "),_("ul",[_("li",[t._v("db.opt，用来存储当前数据库的默认字符集和字符校验规则。")]),t._v(" "),_("li",[t._v("t_order.frm ，t_order 的"),_("strong",[t._v("表结构")]),t._v("会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。")]),t._v(" "),_("li",[t._v("t_order.ibd，t_order 的"),_("strong",[t._v("表数据")]),t._v("会保存在这个文件。 MySQL 中每一张表的数据都存放在一个独立的 .idb 文件。")])])])}),[],!1,null,null,null);v.default=a.exports}}]);