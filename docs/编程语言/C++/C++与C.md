```
/**
 * 对于回溯法，或者dfs的题目
 * 我们一般的写法是：
 * ①先排除绝对错误的情况，直接返回false
 * ②找到出口结束条件，直接返回true
 * ③最重要的！！！找到递归式子，并且记得回溯法的话如果不用了也记得恢复来之前的条件情况
 */
```

# C++

## malloc、new、memset函数解析

- malloc

malloc函数其实就是在内存中找一片指定大小的空间，然后将这个空间的首地址给一个指针变量，这里的指针变量可以是一个单独的指针，也可以是一个数组的首地址，这要看malloc函数中参数size的具体内容。

malloc的实参是sizeof(int)，用于指明一个整型数据需要的大小，如果我们写成

```c
p=(int*)malloc(1)
```

那么可以看出：只是申请了一个一个字节大小的空间。

**malloc只管分配内存，并不能对其进行初始化，所以得到的一片新内存中，其值将是随机的**。一般意义上：我们习惯性的将其初始化为NULL，当然也可以使用memset函数。

- new

new返回指定类型的指针，并且可以自动计算所需要的大小。

```c
int *p;
p = new int;//返回类型为int* ，分配的大小是sizeof(int)
p = new int[100];//返回类型是int*类型，分配的大小为sizeof(int)*100
```

而malloc需要我们自己计算字节数，并且返回的时候要强转成指定类型的指针。

```c
int *p;
p = (int *)malloc(sizeof(int));
```

- memset

```c
# include <string.h>
void *memset(void *s, int c, unsigned long n);
```

函数的功能是：将指针变量 s 所指向的前 n 字节的内存单元用一个“整数” c 替换，注意 c 是 int 型。s 是 void* 型的指针变量，所以它可以为任何类型的数据进行初始化。

memset() 的作用是在一段内存块中填充某个给定的值。因为它只能填充一个值，所以**该函数的初始化为原始初始化**，无法将变量初始化为程序中需要的数据。用memset初始化完后，后面程序中再向该内存空间中存放需要的数据。

```C
char str[10];
char *p = str;
memset(str, 0, sizeof(str));  //只能写sizeof(str), 不能写sizeof(p)
```

memset 函数的第三个参数 n 的值一般用 sizeof() 获取，这样比较专业。注意，如果是对指针变量所指向的内存单元进行清零初始化，那么一定要先对这个指针变量进行初始化，即一定要先让它指向某个有效的地址。而且用memset给指针变量如p所指向的内存单元进行初始化时，n 千万别写成 sizeof(p)，这是新手经常会犯的错误。因为 p 是指针变量，不管 p 指向什么类型的变量，sizeof(p) 的值都是 4。





## 虚函数

虚函数是运行时多态的一种体现。

![image-20220525144900343](https://s2.loli.net/2022/05/25/bmoPX4fMwkIBZ9H.png)

​		在上述例子中，我们首先定义了一个基类base，基类有一个名为**vir_func**的虚函数，和一个名为**func**的普通成员函数。而类A，B都是由类base派生的子类，并且都对成员函数进行了重载。然后我们定义三个base类型的指针Base、a、b分别指向类base、A、B。**可以看到，当使用这三个指针调用func函数时，调用的都是基类base的函数**。**而使用这三个指针调用虚函数vir_func时，调用的是指针指向的实际类型的函数**。最后，我们将指针b做强制类型转换，转换为A类型指针，然后分别调用func和vir_func函数，发现普通函数调用的是类A的函数，而虚函数调用的是类B的函数。

::: tip 重点

  以上，我们可以得出结论**当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定**。

  虚函数的实现过程：**通过对象内存中的vptr找到虚函数表vtbl，接着通过vtbl找到对应虚函数的实现区域并进行调用。**

:::

[(73条消息) 虚函数详解_~青萍之末~的博客-CSDN博客_虚函数](https://blog.csdn.net/daaikuaichuan/article/details/88364336)



概括来说：

对于虚函数，肯定是发生在继承关系中的多态的。

①**单继承**的情况下，如果子类**没有重写**父类的虚函数。那么虚函数表：

![image-20220525145614127](https://s2.loli.net/2022/05/25/UFYpN7HcTkJdulO.png)



②**单继承**的情况下，如果子类对父类的虚函数进行了**重写**，那么：

![在这里插入图片描述](https://s2.loli.net/2022/05/25/48eVSO15b3K6wUo.jpg)



③**多继承**的情况下，没有重写：

![image-20220525145753212](https://s2.loli.net/2022/05/25/5ZtF6bugnpmNG14.png)



④**多继承**的情况下，**重写**了：

<img src="https://s2.loli.net/2022/05/25/a5jbTE78uMd1CQk.png" alt="image-202205251458 41797" style="zoom:50%;" />





## c++内存管理

1. 栈区：函数的参数值、局部变量的值。
2. 堆区：malloc、new等方法开辟，delete、free等方法释放；os也会自动释放。
3. 全局区：static、全局变量、静态变量
4. 常量区：常量
5. 代码区：代码

```c
#include<bits/stdc++.h>
using namespace std;
int p=1;//存储在全局已初始化区
int q;//存储在全局未初始化区
void test(int a)
{
    int b,c;
}//a,b,c均存放在栈区中

int main()
{
    int *ps=new int;//ps存储在栈区中，new出来的内存存储在堆区中
    char str[20]="123456";//str存储在栈区，“123456”为字符串常量存储在常量区
    delete ps;
    return 0;
}

```







## 指针

```c
int *a;			---定义一个指向整型变量的指针a
int **a;		---定义一个指向整型变量指针的指针a
int a[];		---定义一个整型变量数组a
int *a[];		---定义一个指向整型变量指针的数组a
```









## 内存对齐

内存对齐：cpu按照4个字节来寻址（32位操作系统），所以每个数据结构都是在整数倍个4字节的位置。

非内存对齐：每个数据结构可以在地址空间中相邻存放，对于空间浪费较少，但是时间性能差。



**大家可能会发现内存对齐岂不是浪费的内存资源么？**

是这样的，但事实上，相对来说计算机内存资源一般都是充足的，我们更希望的是提高运行速度。

**编译器一般都会做内存对齐的优化操作，也就是说当考虑程序真正占用的内存大小的时候，也需要认识到内存对齐的影响**

