# 计算机网络

## OSI 的七层网络模型，每一层的作用、功能以及有什么协议？

1. **OSI分层    （7层）**  ：物理层			数据链路层			网络层			传输层			会话层			表示层			应用层

    **TCP/IP分层（4层）**：网络接口层        							网际层			运输层		              									 应用层

    **五层协议   （5层）**  ：物理层			数据链路层			网络层			运输层											               应用层

     

    **每一层的协议如下：**

    物理层：RJ45、CLOCK、IEEE802.3   （中继器，集线器，网关）

    数据链路：**PPP**、FR、**HDLC**、VLAN、MAC  （网桥，交换机）

    网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP （路由器）

    传输层：TCP、UDP、SPX

    会话层：NFS、SQL、NETBIOS、RPC

    表示层：JPEG、MPEG、ASII

    应用层：FTP、Telnet、SMTP、HTTP、WWW（都是基于TCP的）NFS、DNS（都是基于UDP的）

     

    **每一层的作用如下：**

    **物理层：**通过媒介传输比特,确定机械及电气规范（比特Bit）

    **数据链路层**：将比特组装成帧和点到点的传递（帧Frame）封装成帧，透明传输

    **网络层**：负责数据包从源到宿的传递和网际互连（包PackeT）

    **传输层**：提供端到端的可靠报文传递和错误恢复（段Segment）

    **会话层**：建立、管理和终止会话（会话协议数据单元SPDU）

    **表示层**：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）

    **应用层**：允许访问OSI环境的手段（应用协议数据单元APDU）







## **ARP协议。**

1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。

2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址。

3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。

4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

**广播发送ARP请求，单播发送ARP响应。**

广播请求，单播回应



## NAT

这种方法需要在专用网连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接。



网络地址转换



## 为什么分层

1.**各层次之间是独立的。**某一层并不需要知道它的下一层是如何实现的，而仅仅需要知道该层通过层间的接口所提供的服务。这样，整个问题的复杂程度就下降了。也就是说上一层的工作如何进行并不影响下一层的工作，这样我们在进行每一层的工作设计时只要保证接口不变可以随意调整层内的工作方式。

2.**灵活性好。**当任何一层发生变化时，只要层间接口关系保持不变，则在这层以上或以下层均不受影响。当某一层出现技术革新或者某一层在工作中出现问题时不会连累到其它层的工作，排除问题时也只需要考虑这一层单独的问题即可。

3.**结构上可分割开。**各层都可以采用最合适的技术来实现。技术的发展往往不对称的，层次化的划分有效避免了木桶效应，不会因为某一方面技术的不完善而影响整体的工作效率。

4.**易于实现和维护**。这种结构使得实现和调试一个庞大又复杂的系统变得易于处理，因为整个的系统已经被分解为若干个相对独立的子系统。进行调试和维护时，可以对每一层进行单独的调试，避免了出现找不到、解决错问题的情况。

5.**能促进标准化工作**。因为每一层的功能及其所提供的服务都已有了精确的说明。标准化的好处就是可以随意替换其中的某一层，对于使用和科研来说十分方便。





## TCP和UDP的异同

**1. TCP和UDP的相同点：**

TCP和UDP都是在网络层，都是传输层协议，都能都是保护网络层的传输，双方的通信都需要开放端口。

![image-20220703101326633](https://s2.loli.net/2022/07/03/npc2w3BFamN8bCj.png)



### 使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?

**运行于 TCP 协议之上的协议** ：

1. **HTTP 协议** ：超文本传输协议（HTTP，HyperText Transfer Protocol)主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。
2. **HTTPS 协议** ：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，**身披 SSL 外衣的 HTTP 协议**
3. **FTP 协议**：文件传输协议 FTP（File Transfer Protocol），提供文件传输服务，**基于 TCP** 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。
4. **SMTP 协议**：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，**基于 TCP 协议**，用来发送电子邮件。注意 ⚠️：接受邮件的协议不是 SMTP 而是 POP3 协议。
5. **POP3/IMAP 协议**： POP3 和 IMAP 两者都是负责邮件接收的协议。
6. **Telent 协议**：远程登陆协议，通过一个终端登陆到其他服务器。被一种称为 SSH 的非常安全的协议所取代。
7. **SSH 协议** : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。
8. ......

**运行于 UDP 协议之上的协议** ：

1. **DHCP 协议**：动态主机配置协议，动态配置 IP 地址
2. **DNS** ： **域名系统（DNS，Domain Name System）将人类可读的域名 (例如，www.baidu.com) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。** 我们可以将其理解为专为互联网设计的电话薄。实际上 DNS 同时支持 UDP 和 TCP 协议。



## 三次握手

**三次握手：**

第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

**握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。**

![image-20220703101922076](https://s2.loli.net/2022/07/03/CXuLIpbjQVFDPzl.png)





数据传输

![123](https://s2.loli.net/2022/07/03/YRey1AV3iwIMXq8.png)







## 四次挥手

**四次握手**

与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。

第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。

第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。

第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。

第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。

<img src="https://s2.loli.net/2022/12/08/NPLo4fpiFUOrdmQ.png" alt="image-20221208151004887" style="zoom: 50%;" />



![image-20221208151642800](https://s2.loli.net/2022/12/08/DEPwi8HGFdCTtkQ.png)

**为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？**（超时等待机制）

第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端没有因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。

> **MSL(Maximum Segment Lifetime)** : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。

------



## **TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？**

答：建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。

（1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。

（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，**主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。**

（3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。(两次请求的话，就缺少了对于B的确认的确认，相当于A发送SYN，B回复ACK，然后就相当于建立成功了。但实际上B的这个ACK确认的SYN是失效了的，如果是三次的话，A就知道B的这个ACK是对于失效SYN的一种回复，A就不会对这种ACK进行确认，也就不会建立连接)





## DNS域名解析



先查看本地域名服务器缓存

没有找上级



<img src="https://s2.loli.net/2022/07/03/GUbRNDvHWsABuxP.png" alt="在这里插入图片描 述" style="zoom:120%;" />

![image-20220703111507749](https://s2.loli.net/2022/07/03/SKecFU4WZ7pyYVw.png)



## http与https

http报文是包裹在tcp报文中发送的，http报文是明文，截取的话会存在信息泄露的风险

HTTPS协议的本质就是HTTP + SSL(or TLS)。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层级结构看它位于HTTP协议与TCP协议之间。





HTTP请求报文是由三部分组成: **请求行**, **请求报头**和**请求正文**。

### HTTP 1.0 和 HTTP 1.1 有什么区别？

- **连接方式** : HTTP 1.0 为短连接，HTTP 1.1 支持长连接。
- **状态响应码** : HTTP/1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。比如说，`100 (Continue)`——在请求大资源前的预热请求，`206 (Partial Content)`——范围请求的标识码，`409 (Conflict)`——请求与当前资源的规定冲突，`410 (Gone)`——资源已被永久转移，而且没有任何已知的转发地址。
- **缓存处理** : 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。
- **带宽优化及网络连接的使用** :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
- **Host头处理** : HTTP/1.1在请求头中加入了`Host`字段。





## HTTP请求过程



1. 浏览器域名进行DNS域名解析
2. 浏览器与WEB服务器建立一个TCP连接
3. 浏览器给web服务器发送一个http请求
4. 服务器端响应HTTP请求，浏览器得到HTML代码
5. 浏览器解析HTML代码，并请求HTML代码中的资源
6. 关闭TCP连接，浏览器对页面进行渲染呈现给用户



## TCP的流量控制？拥塞控制？

流量控制：作用于发送方

如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，**控制发送者的发送速度，使得接收者来得及接收**，这就是流量控制。流量控制根本目的是**防止分组丢失**，它是构成TCP可靠性的一方面。

具体实现：

由**滑动窗口协议**（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是**接收方返回的 ACK 中会包含自己的==接收窗口==的大小，并且利用大小来控制发送方的数据发送。**





拥塞控制：作用于网络，引入拥塞窗口cwnd（发送窗口要小于拥塞窗口，也要小于接收窗口的大小）

拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：

（ 1 ）慢开始、拥塞避免

慢开始，其实并不慢，每次都成倍的增加，1,2,4,8,16（一般ssthresh为16）

![image-20220703114534076](https://s2.loli.net/2022/07/03/kZSaeCwyuJfEXs7.png)





重点！！！

（TCP Tahoe 版本）

无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限ssthresh设置为出现拥塞时的发送窗口大小的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。

![image-20220703114803596](https://s2.loli.net/2022/07/03/j9PBaTepbrNu1k5.png)

例子！！！

> （1）拥塞窗口cwnd初始化为1个报文段，慢开始门限初始值为16
> （2）执行慢开始算法，指数规律增长到第4轮，即cwnd=16=ssthresh，改为执行拥塞避免算法，拥塞窗口按线性规律增长
> （3）假定cwnd=24时，网络出现超时（拥塞），则更新后的ssthresh=12，cwnd重新设置为1，并执行慢开始算法。当cwnd=12=ssthresh时，改为执行拥塞避免算法



（ 2 ）快重传、快恢复。

“TCP Reno版本”（实线版本，虚线为Tahoe版本）

与快重传配合使用的还有快恢复算法，其过程有以下两个要点：

1. 当==发送方连续收到三个重复确认时=，就执行“乘法减小”算法，把慢开始门限ssthresh 减半。这是为了预防网络发生拥塞。请注意，接下去不执行慢开始算法。
2. 由于**发送方现在认为网络很可能没有发生拥塞**（如果网络发生了严重的拥塞，就不会一连有好几个报文段连续到达接收方，也就不会导致接收方连续发送重复确认），因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口 cwnd 现在不设置为 1），**而是把 cwnd 值设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。**

![img](https://pic2.zhimg.com/80/v2-71c881dd3ce05d691b4b7d937dab8a85_720w.jpg)







## DHCP

​		DHCP协议中分为DHCP server服务端和DHCP client客户端。使用DHCP设备的是客户端，提供DHCP服务的是服务端。DHCP服务器是指由服务器控制的一段IP地址范围。DHCP客户端可以自动的从DHCP服务器获得IP地址以及其他的配置参数。
​		DHCP的主要作用就是管理和分配IP地址。他能为大量的主机分配IP地址并能集中管理。其分配地址有三种方式，分别是自动分配、动态分配和手动分配：
1.自动分配方式：DHCP服务器可以为主机分配一个**永久性的IP地址**。当DHCP客户端第一次从DHCP服务端租用到一个IP地址时，就可以永久性的使用该IP地址。
2.动态分配方式：DHCP服务器为主机分配一个**具有时间限制的IP地址**，当时间达到限制或者主机主动放弃该地址时，该地址才能被其他主机使用。
3.手动分配方式：客户端的IP地址由网络管理员指定，DHCP服务器只是将一个指定的IP地址告诉主机。

主要工作原理：DHCP采用UDP发送所有的数据包，主机发送请求到DHCP服务器的68号端口，DHCP服务器再把消息返回给主机的67号端口。







## RIP协议和OSPF协议（路由选择）

二者都是网络层的协议，用于路由器进行路由转发的协议，**确定具体下一跳的位置**的一种协议。



**RIP协议：距离矢量法协议**

基本思想：每个节点都保存一张路由表，路由表包括目的地址，最短距离，最佳输出链路。相邻的节点之间可以定期交换路由信息，并根据最新的路由信息更新自己的路由表。



**OSPF协议，链路状态协议**

采用洪泛法，**dijstra算法**

基本思想：每个节点定期广播自己的路由信息，并根据最新的路由信息更新路由表。**所有路由器都具有全网的拓扑结构图**，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。





## 差错控制

数据链路层上的功能

一个实用的通信系统必须具备发现（即检测）这种差错的能力，并采取某种措施纠正之，使差错被控制在所能允许的尽可能小的范围内，这就是差错控制过程，也是数据链路层的主要功能之一。

对差错编码（如奇偶校验码，检查和或CRC）的检查，可以判定一帧在传输过程中是否发生了错误。一旦发现错误，一般可以采用**反馈重发**的方法来纠正。

这就要求接收方收完一帧后，向发送方反馈一个接收是否正确的信息，使发送方所在此作出是不需要重新发送的决定，也即发送方仅当收到接收方已正确接收的反馈信号后才能认为该帧已经正确发送完毕，否则需要重新发送直至正确为止。

物理信道的突发噪声可能完全“淹没”一帧，即使得整个数据帧或反馈信息帧丢失，这将导致发送方永远收不到接收方发来的反馈信息，从而使传输过程停滞.为了避免出现这种情况，**通常引入计时器(Timer)来限定接收方发回反馈信息的时间间隔，当发送方发送一帧的同时也启动计时器，若在限定时间间隔内未能收到接收方的反馈信息，即计时器超时(Timeout)，则可认为传的帧已出错或丢失，继而要重新发送。**由于同一帧数据可能被重复发送多次，就可能引起接收方多次收到同一帧并将其递交给网络层的危险。为了防止发生这种危险，可以采用**对发送的帧编号的方法，即赋予每帧一个序号，从而使接收方能从该序号来区分是新发送来的帧还是已经接收但又重新发送来的帧,以此来确定要不要将接收到的帧递交给网络层。**数据链路层通过使用计数器和序号来保证每帧最终都被正确地递交给目标网络层一次。







## 3个层次的差错控制



1.条件
要传送如下数据：数据a：1000，数据b：1100，数据c：1110
传送情况：发送端S发送：1000 1100 1110，接受端R接收：1010 [未收到] 1110

2.数据链路层的“差错控制”
此时数据链路层的反应是这样的：
(1) 对于发送端S发送的“数据a 1000 ”，接受端R接收到的却是“1010”，显然，左数第三位的0由于某种原因变为1了，晕，太可怕了吧，好在数据链路层的差错控制可以发现这个（具体参看数据链路层），所以我们得知接受的数据a是错误的，扔掉即可（猜测）。
(2) 对于发送端S发送的“数据b 1100”，接受端R未收到任何数据，数据链路层的“差错控制”在此也无能为力了。
(3) 对于发送端S发送的“数据c 1110”，接受端R接收到“1110”，经数据链路层的“差错控制”方法-CRC检验，发现无误，正常接受。
由此可见， 仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受(accept。即“凡是接收端数据链路层接受的帧都是正确的”。

3.运输层的“差错控制”
先啰嗦一句，数据链路层之上是网络层，在之上是运输层。所以，传送的数据是想经过数据链路层处理后在给运输层的，即运输层收到的信号绝不存在”0变为1，1变为0的情况“（这正是数据链路层的差错控制所做的）。现在，在让我们看看运输层的反应吧。
(1) 对于发送端S发送的“数据a 1000”，由于数据链路层发现该数据有误，所以就把它仍丢了。这对运输层而言，就是未收到，所以要求发送端S重传……。
(2) 对于发送端S发送的“数据b 1100 ”，运输层仍未收到，所以要求发送端S重传……。
(3) 对于发送端S发送的“数据c 1110”，经数据链路层处理后交与运输层，运输层先发送端S返回确认帧，表示已经收到。

4.总结
对于数据链路层而言，只保证接受到的数据没问题，至于中间丢失的数据压根不管。而运输层则对中途丢失的数据也做管理，它会通知发送端说：“数据b怎么没有发？再发一遍“。





## 子网掩码

子网掩码是为了区分ip地址主机号和网络号的

![image-20221010093819612](https://s2.loli.net/2022/10/10/Jyskq9OV8wnlbdQ.png)

对于上述这个例子，子网掩码是255.255.255.252



对于一个新的ip地址，看子网掩码前面有多少个1就知道，这个网络号是多少，主机号是多少



CIDR写法：192.168.0.0/30

这里30是指，掩码有30个1